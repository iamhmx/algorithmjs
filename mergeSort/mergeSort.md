### 思路
1. 将数组划分为左右2个子数组，递归调用，直到子数组只有1个元素
2. 分别对子数组排序
3. 将排好序的子数组合并成完整的有序数组

### 时间复杂度
<table>
<thead>
<tr>
<th align="center">最好</th>
<th align="center">平均</th>
<th align="center">最坏</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">n&nbsp;log(n)</td>
<td align="center">n&nbsp;log(n)</td>
<td align="center">n&nbsp;log(n)</td>
<td align="center">稳定</td>
</tr>
</tbody>
</table>

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif">

以数组：`arr = [7, 9, 2, 6, 14, 12]`为例，归并过程如下：
```js
当前arr： [ 7, 9, 2, 6, 14, 12 ]
------------------------------------
当前arr： [ 7, 9, 2 ]
------------------------------------
当前arr： [ 7, 9 ]
------------------------------------
当前arr： [ 7 ]
------------------------------------
当前arr： [ 9 ]
------------------------------------
开始合并：
左边： [ 7 ]
右边： [ 9 ]
合并结果： [ 7, 9 ]
====================================
当前arr： [ 2 ]
------------------------------------
开始合并：
左边： [ 7, 9 ]
右边： [ 2 ]
合并结果： [ 2, 7, 9 ]
====================================
当前arr： [ 6, 14, 12 ]
------------------------------------
当前arr： [ 6, 14 ]
------------------------------------
当前arr： [ 6 ]
------------------------------------
当前arr： [ 14 ]
------------------------------------
开始合并：
左边： [ 6 ]
右边： [ 14 ]
合并结果： [ 6, 14 ]
====================================
当前arr： [ 12 ]
------------------------------------
开始合并：
左边： [ 6, 14 ]
右边： [ 12 ]
合并结果： [ 6, 12, 14 ]
====================================
开始合并：
左边： [ 2, 7, 9 ]
右边： [ 6, 12, 14 ]
合并结果： [ 2, 6, 7, 9, 12, 14 ]
====================================
```

### 实现
```js
/**
 * @description: 归并排序
 * @param {type} arr：待排序数组
 * @param {type} l：左边界
 * @param {type} r：右边界
 */
function mergeSort(arr, l, r) {
  if (l === r) {
    return
  }
  
  let mid  = (l + r) >> 1
  let count = 0
  // 划分左边
  mergeSort(arr, l, mid)
  // 划分右边
  mergeSort(arr, mid + 1, r)
  // 合并
  merge(arr, l, mid, r, count)
  
}

function merge(arr, l, mid, r) {
  // 保存合并的数组
  let temp = []
  // 左边子数组第一个元素
  let p1 = l
  // 右边子数组第一个元素
  let p2 = mid + 1
  // 下标
  let k = 0
  while (p1 <= mid || p2 <= r) {
    // 右边子数组没有元素 或者 左边元素 <= 右边元素，将左边元素放入，否则放入右边元素
    if (p2 > r || (p1 <= mid && arr[p1] <= arr[p2])) {
      temp[k++] = arr[p1++]
    } else {
      temp[k++] = arr[p2++]
    }
  }
  // 将排序好的数还原回原数组
  for (let i = 0, j = l; i < k; i++, j++) {
    arr[j] = temp[i]
  }
}

//测试
let arr = [7, 9, 2, 6, 14, 12]
mergeSort(arr, 0, arr.length - 1)
```